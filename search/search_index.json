{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Snykey Documentation","text":"<p>Welcome to the documentation for Snykey!</p> <p></p> <p></p>"},{"location":"index.html#what-is-snykey","title":"What is Snykey?","text":"<p>Snykey is a centralized service for managing and distributing Snyk API credentials to your applications. It ensures your software always has access to valid Snyk access tokens, while securely storing and rotating refresh keys using OpenBao (Vault). This removes the persistence and secrets management burden from your application code.</p>"},{"location":"index.html#key-features","title":"Key Features","text":"<ul> <li>Centralized Snyk credential management</li> <li>Secure storage and rotation of refresh keys</li> <li>REST API for requesting and updating credentials</li> <li>OpenBao integration for robust secrets management</li> <li>Easy deployment with Docker Compose</li> <li>Easy App Creation providing all necessary endpoints for app registration.</li> </ul>"},{"location":"index.html#how-it-works","title":"How It Works","text":"<ul> <li>Applications request Snyk access tokens from the manager via the REST API.</li> <li>The manager retrieves and refreshes tokens as needed, using securely stored refresh keys.</li> <li>All secrets are stored in OpenBao, ensuring strong security and auditability.</li> </ul>"},{"location":"index.html#quick-start","title":"Quick Start","text":"<ol> <li>Clone the repository and configure your environment.</li> <li>Run the <code>setup.sh</code> script to prepare directories, configs, and certificates.</li> <li>Start the stack with Docker Compose.</li> <li>Initialize and unseal OpenBao (see Installation for details).</li> <li>Enable the KV secrets engine in OpenBao.</li> <li>Use the API to store and retrieve Snyk credentials for your applications.</li> </ol>"},{"location":"index.html#documentation-sections","title":"Documentation Sections","text":"<ul> <li>Installation: Step-by-step setup guide</li> <li>Configuration: Environment variables and service configuration</li> <li>API Reference: REST API endpoints and usage</li> </ul>"},{"location":"index.html#running-tests","title":"Running Tests","text":"<p>To run the test suite:</p> <pre><code>pip install -r tests/requirements.txt\npytest snykey/tests\n</code></pre>"},{"location":"index.html#openbao-setup-summary","title":"OpenBao Setup (Summary)","text":"<ol> <li> <p>Initialize OpenBao: <pre><code>docker exec -it openbao bao operator init -n 1 -t 1\n</code></pre></p> </li> <li> <p>Unseal and login: <pre><code>docker exec -it openbao bao operator unseal $OPENBAO_UNSEAL_KEY\ndocker exec -it openbao bao login $OPENBAO_TOKEN\n</code></pre></p> </li> <li> <p>Enable secrets engine: <pre><code>docker exec -it openbao bao secrets enable -version=2 kv\n</code></pre></p> </li> </ol>"},{"location":"endpoints/v1.html","title":"v1","text":""},{"location":"endpoints/v1.html#v1-endpoints","title":"V1 Endpoints","text":""},{"location":"endpoints/v1.html#overview","title":"Overview","text":"<p>This API provides endpoints for securely storing, retrieving, and deleting Snyk credentials using OpenBao (Vault) and Redis as backends. All endpoints are versioned under <code>/credentials</code> and <code>/cache</code>.</p>"},{"location":"endpoints/v1.html#authentication","title":"Authentication","text":"<p>This API does not implement authentication by default. If you deploy in production, you should secure the API (e.g., with a reverse proxy, network policy, or FastAPI dependencies).</p>"},{"location":"endpoints/v1.html#error-handling","title":"Error Handling","text":"<ul> <li>All endpoints return JSON responses.</li> <li>On error, the response will include an <code>error</code> field and an appropriate HTTP status code (e.g., 400, 404, 500, 503).</li> </ul> <p>Example error response: <pre><code>{\n  \"error\": \"Vault is sealed, cannot store credentials.\"\n}\n</code></pre></p>"},{"location":"endpoints/v1.html#endpoint-overview","title":"Endpoint Overview","text":""},{"location":"endpoints/v1.html#api.v1.endpoints.delete_cache_key","title":"<code>delete_cache_key</code>  <code>async</code>","text":"<p>Deletes the Snyk auth token for the specified org/client from Redis.</p> <p>Parameters:</p> Name Type Description Default <code>org_id</code> <code>str</code> <p>The organization ID.</p> required <code>client_id</code> <code>str</code> <p>The client ID.</p> required <p>Returns:</p> Name Type Description <code>JSONResponse</code> <code>JSONResponse</code> <p>A confirmation message indicating the auth token was deleted.</p> Source code in <code>snykey/api/v1/endpoints.py</code> <pre><code>@router.delete(\"/cache\")\nasync def delete_cache_key(org_id: str, client_id: str) -&gt; JSONResponse:\n    \"\"\"\n    Deletes the Snyk auth token for the specified org/client from Redis.\n\n    Args:\n        org_id (str): The organization ID.\n        client_id (str): The client ID.\n\n    Returns:\n        JSONResponse: A confirmation message indicating the auth token was deleted.\n    \"\"\"\n\n    org_id = org_id.strip()\n    client_id = client_id.strip()\n\n    response: dict = await redis.delete_auth_token(org_id, client_id)\n\n    return JSONResponse(content=response)\n</code></pre>"},{"location":"endpoints/v1.html#api.v1.endpoints.delete_credentials","title":"<code>delete_credentials</code>  <code>async</code>","text":"<p>Delete Snyk credentials for a given org_id and client_id.</p> <p>Parameters:</p> Name Type Description Default <code>org_id</code> <code>str</code> <p>The organization ID.</p> required <code>client_id</code> <code>str</code> <p>The client ID.</p> required <p>Returns:</p> Name Type Description <code>JSONResponse</code> <code>JSONResponse</code> <p>A response indicating success or failure of the deletion.</p> Source code in <code>snykey/api/v1/endpoints.py</code> <pre><code>@router.delete(\"/credentials\")\nasync def delete_credentials(org_id: str, client_id: str) -&gt; JSONResponse:\n    \"\"\"\n    Delete Snyk credentials for a given org_id and client_id.\n\n    Args:\n        org_id (str): The organization ID.\n        client_id (str): The client ID.\n\n    Returns:\n        JSONResponse: A response indicating success or failure of the deletion.\n    \"\"\"\n\n    org_id = org_id.strip()\n    client_id = client_id.strip()\n\n    if not org_id or not client_id:\n        return JSONResponse(\n            status_code=400, content={\"error\": \"org_id and client_id are required\"}\n        )\n\n    # Delete auth token from Redis\n    logger.info(\n        \"Deleting auth token from Redis for org_id: %s, client_id: %s\",\n        org_id,\n        client_id,\n    )\n\n    await redis.delete_auth_token(org_id, client_id)\n\n    await openbao.delete_refresh_key(org_id, client_id)\n\n    return JSONResponse(content={\"message\": \"Credentials deleted.\"})\n</code></pre>"},{"location":"endpoints/v1.html#api.v1.endpoints.get_credentials","title":"<code>get_credentials</code>  <code>async</code>","text":"<p>Gather Snyk credentials using the provided org_id and client_id.</p> <p>Parameters:</p> Name Type Description Default <code>org_id</code> <code>str</code> <p>The organization ID.</p> required <code>client_id</code> <code>str</code> <p>The client ID.</p> required <p>Returns:</p> Name Type Description <code>JSONResponse</code> <code>JSONResponse</code> <p>A response containing the gathered credentials or an error message.</p> Source code in <code>snykey/api/v1/endpoints.py</code> <pre><code>@router.get(\"/credentials\")\nasync def get_credentials(\n    org_id: str, client_id: str, client_secret: str\n) -&gt; JSONResponse:\n    \"\"\"\n    Gather Snyk credentials using the provided org_id and client_id.\n\n    Args:\n        org_id (str): The organization ID.\n        client_id (str): The client ID.\n\n    Returns:\n        JSONResponse: A response containing the gathered credentials or an error message.\n    \"\"\"\n\n    org_id = org_id.strip()\n    client_id = client_id.strip()\n    client_secret = client_secret.strip()\n\n    # Check if auth token exists in Redis\n    logger.info(\n        \"Checking Redis for auth token for org_id: %s, client_id: %s\",\n        org_id,\n        client_id,\n    )\n\n    auth_token: bytes | None = None\n\n    try:\n        auth_token = await redis.get_auth_token(org_id, client_id)\n    except Exception as e:\n        logger.error(\"Failed to retrieve auth token from Redis: %s\", e)\n\n    if auth_token:\n        logger.info(\"Found auth token in Redis\")\n        return JSONResponse(content={\"access_token\": str(auth_token.decode())})\n\n    # Get refresh key from OpenBao\n    logger.info(\n        \"Gathering Snyk credentials for org_id: %s, client_id: %s\",\n        org_id,\n        client_id,\n    )\n\n    refresh_key: str | None = None\n\n    try:\n        refresh_key = await openbao.get_refresh_key(org_id, client_id)\n    except Exception as e:\n        logger.error(\"Failed to retrieve refresh key from OpenBao: %s\", e)\n\n    if not refresh_key:\n        return JSONResponse(\n            status_code=404, content={\"error\": \"No refresh key found for org/client\"}\n        )\n\n    # Refresh Snyk token\n    logger.info(\n        \"Refreshing Snyk token for org_id: %s, client_id: %s\", org_id, client_id\n    )\n\n    expires_in: int = 3600\n\n    try:\n        result: dict = await snyk.refresh_snyk_token(\n            client_id, client_secret, refresh_key\n        )\n\n        logger.info(\n            \"Successfully refreshed Snyk token for org_id: %s, client_id: %s\",\n            org_id,\n            client_id,\n        )\n\n        expires_in = result.get(\"expires_in\", 3600)\n\n        await openbao.update_refresh_key(org_id, client_id, result[\"refresh_token\"])\n    except Exception as e:\n        logger.error(\"Failed to refresh Snyk token: %s\", e)\n        return JSONResponse(status_code=500, content={\"error\": str(e)})\n\n    try:\n        await redis.store_auth_token(\n            org_id,\n            client_id,\n            str(result[\"access_token\"]),\n            expiration=min(settings.REDIS_CACHE_TIME, expires_in),\n        )\n    except Exception as e:\n        logger.error(\"Failed to store auth token in Redis: %s\", e)\n        return JSONResponse(status_code=500, content={\"error\": str(e)})\n\n    return JSONResponse(content={\"access_token\": str(result[\"access_token\"])})\n</code></pre>"},{"location":"endpoints/v1.html#api.v1.endpoints.oauth_callback","title":"<code>oauth_callback</code>  <code>async</code>","text":"<p>OAuth callback endpoint to handle the authorization code flow.</p> <p>This endpoint receives the authorization code from Snyk, retrieves the PKCE data (which includes org_id), exchanges the code for tokens, and stores the refresh token in OpenBao.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>The authorization code from Snyk.</p> <code>Query(..., description='Authorization code from Snyk')</code> <code>state</code> <code>str</code> <p>The state parameter for CSRF protection.</p> <code>Query(..., description='State parameter for CSRF protection')</code> <code>instance</code> <code>str</code> <p>The Snyk instance (default: api.snyk.io).</p> <code>Query(default='api.snyk.io', description='Snyk instance')</code> <p>Returns:</p> Name Type Description <code>JSONResponse</code> <code>JSONResponse</code> <p>A response indicating success or failure.</p> Source code in <code>snykey/api/v1/endpoints.py</code> <pre><code>@router.get(\"/callback\")\nasync def oauth_callback(\n    code: str = Query(..., description=\"Authorization code from Snyk\"),\n    state: str = Query(..., description=\"State parameter for CSRF protection\"),\n    instance: str = Query(default=\"api.snyk.io\", description=\"Snyk instance\"),\n) -&gt; JSONResponse:\n    \"\"\"\n    OAuth callback endpoint to handle the authorization code flow.\n\n    This endpoint receives the authorization code from Snyk, retrieves the PKCE data\n    (which includes org_id), exchanges the code for tokens, and stores the refresh token in OpenBao.\n\n    Args:\n        code (str): The authorization code from Snyk.\n        state (str): The state parameter for CSRF protection.\n        instance (str): The Snyk instance (default: api.snyk.io).\n\n    Returns:\n        JSONResponse: A response indicating success or failure.\n    \"\"\"\n\n    logger.info(\"Received OAuth callback with state: %s\", state)\n\n    # Retrieve PKCE data from Redis using state\n    pkce_data: dict | None = await redis.get_pkce_data(state.strip())\n\n    if not pkce_data:\n        logger.error(\"PKCE data not found for state: %s\", state)\n        return JSONResponse(\n            status_code=400, content={\"error\": \"Invalid or expired state parameter\"}\n        )\n\n    code_verifier: str = pkce_data.get(\"code_verifier\")\n    client_id: str = pkce_data.get(\"client_id\").strip()\n    client_secret: str = pkce_data.get(\"client_secret\")\n    redirect_uri: str = pkce_data.get(\"redirect_uri\")\n    org_id: str = pkce_data.get(\"org_id\").strip()\n\n    if not all([code_verifier, client_id, client_secret, redirect_uri, org_id]):\n        logger.error(\"Incomplete PKCE data for state: %s\", state)\n        return JSONResponse(status_code=500, content={\"error\": \"Incomplete PKCE data\"})\n\n    if await openbao.check_vault_sealed():\n        logger.error(\"Vault is sealed, cannot proceed with OAuth callback\")\n        return JSONResponse(\n            status_code=503,\n            content={\"error\": \"Vault is sealed, cannot store credentials.\"},\n        )\n\n    refresh_token: str | None = None\n    access_token: str | None = None\n    expires_in: int = 3600\n\n    logger.info(\"Exchanging authorization code for tokens\")\n    try:\n        token_response: dict = await snyk.exchange_code_for_token(\n            code=code,\n            client_id=client_id,\n            client_secret=client_secret,\n            redirect_uri=redirect_uri,\n            code_verifier=code_verifier,\n        )\n\n        refresh_token = token_response.get(\"refresh_token\")\n        access_token = token_response.get(\"access_token\")\n        expires_in = token_response.get(\"expires_in\", 3600)\n\n        logger.info(\"Successfully exchanged code for tokens\")\n\n    except Exception as e:\n        logger.error(\"Failed to exchange code for tokens: %s\", e)\n        # Clean up PKCE data on failure\n        await redis.delete_pkce_data(state)\n        return JSONResponse(\n            status_code=500,\n            content={\"error\": f\"Failed to exchange code for tokens: {str(e)}\"},\n        )\n\n    logger.info(\n        \"Storing refresh token in OpenBao for org_id: %s, client_id: %s\",\n        org_id,\n        client_id,\n    )\n    try:\n        await openbao.store_refresh_key(org_id, client_id, refresh_token)\n        logger.info(\"Successfully stored refresh token in OpenBao\")\n    except Exception as e:\n        logger.error(\"Failed to store refresh token in OpenBao: %s\", e)\n\n        await redis.delete_pkce_data(state)\n        return JSONResponse(\n            status_code=500,\n            content={\"error\": f\"Failed to store refresh token: {str(e)}\"},\n        )\n\n    logger.info(\"Storing access token in Redis cache\")\n    try:\n        await redis.store_auth_token(\n            org_id=org_id,\n            client_id=client_id,\n            auth_token=access_token,\n            expiration=min(expires_in, settings.REDIS_CACHE_TIME),\n        )\n        logger.info(\"Successfully stored access token in Redis\")\n    except Exception as e:\n        logger.warning(\"Failed to store access token in Redis cache: %s\", e)\n\n    await redis.delete_pkce_data(state)\n    logger.info(\"OAuth callback completed successfully\")\n\n    return JSONResponse(\n        content={\n            \"message\": \"Successfully authenticated and stored credentials\",\n            \"org_id\": org_id,\n            \"client_id\": client_id,\n        }\n    )\n</code></pre>"},{"location":"endpoints/v1.html#api.v1.endpoints.register_app","title":"<code>register_app</code>  <code>async</code>","text":"<p>Register a new Snyk app with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the Snyk app.</p> required <code>scopes</code> <code>str</code> <p>Comma-separated list of scopes for the Snyk app.</p> required <code>redirect_uris</code> <code>str</code> <p>Comma-separated list of redirect URIs for the Snyk app. The first one is assumed for storing PKCE data.</p> required <code>org_id</code> <code>str</code> <p>Snyk organization ID (stored in PKCE data for callback).</p> required <code>auth_token</code> <code>str</code> <p>Snyk authentication token.</p> required <p>Returns:</p> Name Type Description <code>JSONResponse</code> <code>JSONResponse</code> <p>A response containing the registered app details or an error message.</p> Source code in <code>snykey/api/v1/endpoints.py</code> <pre><code>@router.post(\"/register-app\")\nasync def register_app(\n    name: str,\n    scopes: str,\n    redirect_uris: str,\n    org_id: str,\n    auth_token: str,\n) -&gt; JSONResponse:\n    \"\"\"\n    Register a new Snyk app with the specified parameters.\n\n    Args:\n        name (str): Name of the Snyk app.\n        scopes (str): Comma-separated list of scopes for the Snyk app.\n        redirect_uris (str): Comma-separated list of redirect URIs for the Snyk app. The first one is assumed for storing PKCE data.\n        org_id (str): Snyk organization ID (stored in PKCE data for callback).\n        auth_token (str): Snyk authentication token.\n\n    Returns:\n        JSONResponse: A response containing the registered app details or an error message.\n    \"\"\"\n\n    code_verifier: str | None = None\n    code_challenge: str | None = None\n    state: str | None = None\n\n    used_states: list[str] = await redis.get_all_states()\n\n    try:\n        code_verifier = await oauth.generate_code_verifier()\n        code_challenge = await oauth.generate_code_challenge(code_verifier)\n\n        while not (state and state not in used_states):\n            state = await oauth.generate_state()\n\n    except Exception as e:\n        logger.error(\"Failed to generate OAuth parameters: %s\", e)\n        return JSONResponse(status_code=500, content={\"error\": str(e)})\n\n    org_id = org_id.strip()\n    auth_token = auth_token.strip()\n    name = name.strip()\n\n    scopes_list: list[str] = [s.strip() for s in scopes.split(\",\")]\n    redirect_uris_list: list[str] = [u.strip() for u in redirect_uris.split(\",\")]\n\n    if len(redirect_uris_list) == 0:\n        return JSONResponse(\n            status_code=400, content={\"error\": \"At least one redirect URI is required\"}\n        )\n\n    result: dict = {}\n\n    try:\n        result = await snyk.register_snyk_app(\n            name, scopes_list, redirect_uris_list, org_id, auth_token\n        )\n    except Exception as e:\n        logger.error(\"Failed to register Snyk app: %s\", e)\n        return JSONResponse(status_code=500, content={\"error\": str(e)})\n\n    client_id: str | None = (\n        result.get(\"data\", {}).get(\"attributes\", {}).get(\"client_id\", None)\n    )\n    client_secret: str | None = (\n        result.get(\"data\", {}).get(\"attributes\", {}).get(\"client_secret\", None)\n    )\n\n    if client_id is None:\n        logger.error(\"Client ID not found in Snyk app registration response.\")\n        return JSONResponse(\n            status_code=500, content={\"error\": \"Client ID not found in response.\"}\n        )\n\n    auth_urls: dict = {}\n\n    for uri in redirect_uris_list:\n        auth_url: str = snyk.generate_auth_url(\n            client_id=client_id,\n            redirect_uri=uri,\n            scopes=scopes_list,\n            state=state,\n            code_challenge=code_challenge,\n            code_challenge_method=\"S256\",\n        )\n\n        auth_urls[uri] = auth_url\n\n    result[\"auth_urls\"] = auth_urls\n\n    await redis.store_pkce_data(\n        state=state,\n        code_verifier=code_verifier,\n        client_id=client_id,\n        client_secret=client_secret,\n        redirect_uri=redirect_uris_list[\n            0\n        ],  # Assuming the first redirect URI is used for storing\n        org_id=org_id,\n        expiration=settings.REDIS_PKCE_EXPIRATION,\n    )\n\n    return JSONResponse(content=result)\n</code></pre>"},{"location":"endpoints/v1.html#api.v1.endpoints.store_credentials","title":"<code>store_credentials</code>  <code>async</code>","text":"<p>Store Snyk credentials in OpenBao.</p> <p>Parameters:</p> Name Type Description Default <code>org_id</code> <code>str</code> <p>The organization ID.</p> required <code>client_id</code> <code>str</code> <p>The client ID.</p> required <code>client_secret</code> <code>str</code> <p>The client secret.</p> required <code>refresh_key</code> <code>str</code> <p>The refresh key.</p> required <p>Returns:</p> Name Type Description <code>JSONResponse</code> <code>JSONResponse</code> <p>A response indicating success or failure.</p> Source code in <code>snykey/api/v1/endpoints.py</code> <pre><code>@router.put(\"/credentials\")\nasync def store_credentials(\n    org_id: str, client_id: str, client_secret: str, refresh_key: str\n) -&gt; JSONResponse:\n    \"\"\"\n    Store Snyk credentials in OpenBao.\n\n    Args:\n        org_id (str): The organization ID.\n        client_id (str): The client ID.\n        client_secret (str): The client secret.\n        refresh_key (str): The refresh key.\n\n    Returns:\n        JSONResponse: A response indicating success or failure.\n    \"\"\"\n\n    org_id = org_id.strip()\n    client_id = client_id.strip()\n    client_secret = client_secret.strip()\n    refresh_key = refresh_key.strip()\n\n    if await openbao.check_vault_sealed():\n        return JSONResponse(\n            status_code=503,\n            content={\"error\": \"Vault is sealed, cannot store credentials.\"},\n        )\n\n    logger.info(\"Refreshing key to ensure no other process can use it.\")\n    try:\n        result: dict = await snyk.refresh_snyk_token(\n            client_id, client_secret, refresh_key\n        )\n\n        logger.info(\n            \"Successfully refreshed Snyk token for org_id: %s, client_id: %s\",\n            org_id,\n            client_id,\n        )\n\n        await openbao.store_refresh_key(org_id, client_id, result[\"refresh_token\"])\n    except Exception as e:\n        logger.error(\"Failed to refresh Snyk token: %s\", e)\n        return JSONResponse(status_code=500, content={\"error\": str(e)})\n\n    return JSONResponse(content={\"message\": \"Credentials stored.\"})\n</code></pre>"},{"location":"getting-started/configuration.html","title":"Configuration","text":"<p>Snykey is highly configurable to fit a variety of deployment environments. Below are the main configuration options you can adjust to suit your needs.</p>"},{"location":"getting-started/configuration.html#environment-variables","title":"Environment Variables","text":"<p>Most configuration is handled via environment variables, typically set in your <code>.env</code> file or passed directly to Docker Compose. See <code>.env_example</code> for a template.</p> Variable Description Default/Example <code>OPENBAO_ADDR</code> URL for the OpenBao server <code>https://openbao:8200</code> <code>OPENBAO_TOKEN</code> Root token for OpenBao (set after init) <code>OPENBAO_UNSEAL_KEY</code> Unseal key for OpenBao (set after init) <code>REDIS_HOST</code> Hostname for Redis <code>redis</code> <code>REDIS_PORT</code> Port for Redis <code>6379</code> <code>REDIS_PASSWORD</code> Password for Redis <code>example_password</code> <code>REDIS_CACHE_TIME</code> Cache time (in seconds) for Redis tokens <code>3000</code> <code>REDIS_PKCE_EXPIRATION</code> Cache time (in seconds) for app registration uri to have valid callback <code>600</code> <code>EXCLUDED_PATHS</code> Comma seperated endpoints to ignore middleware for <code>/docs,/openapi.json</code> <code>API_KEY</code> The key required for middleware, uses the header: 'X-API-Key'. To disable, remove the entry <code>example_api_key_1234567890</code> <p>You can modify these in your <code>.env</code> file or override them in your deployment environment.</p>"},{"location":"getting-started/configuration.html#redis-configuration","title":"Redis Configuration","text":"<p>Redis is configured via <code>configs/redis_config.conf</code>. You can adjust:</p> <ul> <li>Port: Change the <code>port</code> directive.</li> <li>Password: Set <code>requirepass</code> to your desired password.</li> <li>Persistence: Adjust <code>appendonly</code> and <code>appendfsync</code> for durability/performance.</li> <li>Logging: Change <code>loglevel</code> as needed.</li> </ul> <p>Example: <pre><code>port 6379\nloglevel debug\nbind 0.0.0.0\n\nrequirepass example_password\n\nappendonly yes\nappendfsync everysec\n</code></pre></p>"},{"location":"getting-started/installation.html","title":"Installation","text":"<p>Follow these steps to install and set up Snykey.</p>"},{"location":"getting-started/installation.html#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/Will-Hellinger/snykey.git\ncd snykey\n</code></pre>"},{"location":"getting-started/installation.html#2-prepare-configuration","title":"2. Prepare Configuration","text":"<p>Copy .env_example to .env and fill in your secrets and environment-specific values. Adjust any configuration in configs/ if needed.</p>"},{"location":"getting-started/installation.html#3-run-the-setup-scripts","title":"3. Run the Setup Scripts","text":"<p>The setup scripts will:</p> <ul> <li>Create required directories and volume mounts</li> <li>Copy configuration files for OpenBao and Redis</li> <li>Generate self-signed certificates for local development</li> </ul> <p>Run: <code>python3 ./scripts/setup.py</code> Run: <code>python3 ./scripts/genreate_certs.py</code></p>"},{"location":"getting-started/installation.html#4-set-the-configuration","title":"4. Set the configuration","text":"<p>The setup needs an initial configuration .env file. You dont need to know the OPENBAO details just yet.</p> <pre><code>cp .env_example .env\n</code></pre>"},{"location":"getting-started/installation.html#5-start-the-stack","title":"5. Start the Stack","text":"<p>Start all services with Docker Compose:</p> <pre><code>docker compose up -d --build\n</code></pre>"},{"location":"getting-started/installation.html#6-initialize-and-unseal-openbao","title":"6. Initialize and Unseal OpenBao","text":""},{"location":"getting-started/installation.html#a-initialize-openbao-first-time-only","title":"a. Initialize OpenBao (first time only):","text":"<pre><code>docker exec -it openbao bao operator init -n 1 -t 1\n</code></pre> <ul> <li>Save the Unseal Key and Root Token from the output.</li> <li>Add them to your .env file as OPENBAO_UNSEAL_KEY and OPENBAO_TOKEN.</li> </ul>"},{"location":"getting-started/installation.html#b-restart-the-stack","title":"b. Restart the Stack","text":"<pre><code>docker compose down\n</code></pre> <pre><code>docker compose up -d\n</code></pre>"},{"location":"getting-started/installation.html#c-unseal-openbao","title":"c. Unseal OpenBao:","text":"<pre><code>docker exec -it openbao bao operator unseal $OPENBAO_UNSEAL_KEY\n</code></pre>"},{"location":"getting-started/installation.html#d-login-to-openbao","title":"d. Login to OpenBao:","text":"<pre><code>docker exec -it openbao bao login $OPENBAO_TOKEN\n</code></pre>"},{"location":"getting-started/installation.html#7-enable-the-key-value-secrets-engine","title":"7. Enable the Key-Value Secrets Engine","text":"<p>Enable the KV secrets engine (version 2):</p> <pre><code>docker exec -it openbao bao secrets enable -version=2 kv\n</code></pre>"},{"location":"getting-started/installation.html#8-optional-verify-everything-is-running","title":"8. (Optional) Verify Everything is Running","text":"<ul> <li>Visit <code>https://localhost:8000/docs</code> for the API docs.</li> <li>Check logs in .container_volumes/app/logs/ if needed.</li> </ul>"},{"location":"getting-started/installation.html#9-next-steps","title":"9. Next Steps","text":"<ul> <li>Use the API to store and retrieve Snyk credentials for your applications.</li> <li>For production, replace the generated certificates with your own trusted certificates.</li> </ul>"},{"location":"scripts/generate-certificates.html","title":"Certificate Generation Script","text":""},{"location":"scripts/generate-certificates.html#overview","title":"Overview","text":"<p>This Bash script automates the creation of a local Certificate Authority (CA) and generates signed TLS certificates for two entities: \"OpenBao\" and \"App\". It uses OpenSSL to generate private keys, certificate signing requests (CSRs), and signed certificates, including Subject Alternative Names (SANs) for both server and client authentication. The script is designed to be used in development or testing environments where self-signed certificates are sufficient.</p>"},{"location":"scripts/generate-certificates.html#features","title":"Features","text":"<ul> <li>Creates a local CA with its own private key and certificate.</li> <li>Generates private keys and CSRs for \"OpenBao\" and \"App\".</li> <li>Signs the CSRs with the local CA, producing valid certificates.</li> <li>Supports custom configuration for certificate subject fields and SANs.</li> <li>Cleans up intermediate files and sets secure permissions on keys and certificates.</li> </ul>"},{"location":"scripts/generate-certificates.html#source","title":"Source","text":"<pre><code>import os\nimport argparse\nimport ipaddress\nfrom cryptography import x509\nfrom cryptography.x509.oid import NameOID\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.x509 import DNSName, IPAddress, SubjectAlternativeName\nfrom datetime import datetime, timedelta, timezone\n\nDEFAULT_CERT_DIR: str = \".container_volumes/certs\"\nDEFAULT_COUNTRY: str = \"US\"\nDEFAULT_STATE: str = \"State\"\nDEFAULT_CITY: str = \"City\"\nDEFAULT_ORG: str = \"OrgName\"\nDEFAULT_CA_CN: str = \"InternalCA\"\nDEFAULT_BAO_CN: str = \"openbao\"\nDEFAULT_APP_CN: str = \"app\"\nDEFAULT_BAO_SANS: tuple[str] = (\n    \"DNS:openbao\",\n    \"DNS:localhost\",\n    \"DNS:host.docker.internal\",\n    \"IP:127.0.0.1\",\n)\nDEFAULT_APP_SANS: tuple[str] = (\n    \"DNS:app\",\n    \"DNS:localhost\",\n    \"DNS:host.docker.internal\",\n    \"IP:127.0.0.1\",\n)\n\n\ndef parse_args() -&gt; argparse.Namespace:\n    parser: argparse.ArgumentParser = argparse.ArgumentParser(\n        description=\"Generate CA, OpenBao, and App certificates.\"\n    )\n\n    parser.add_argument(\"-d\", \"--dir\", default=DEFAULT_CERT_DIR, help=\"Output cert dir\")\n    parser.add_argument(\"-c\", \"--country\", default=DEFAULT_COUNTRY)\n    parser.add_argument(\"-s\", \"--state\", default=DEFAULT_STATE)\n    parser.add_argument(\"-l\", \"--city\", default=DEFAULT_CITY)\n    parser.add_argument(\"-o\", \"--org\", default=DEFAULT_ORG)\n    parser.add_argument(\"--ca-cn\", default=DEFAULT_CA_CN)\n    parser.add_argument(\"--bao-cn\", default=DEFAULT_BAO_CN)\n    parser.add_argument(\"--app-cn\", default=DEFAULT_APP_CN)\n    parser.add_argument(\"--bao-sans\", default=\",\".join(DEFAULT_BAO_SANS))\n    parser.add_argument(\"--app-sans\", default=\",\".join(DEFAULT_APP_SANS))\n\n    return parser.parse_args()\n\n\ndef parse_sans(sans_str: str) -&gt; list:\n    \"\"\"\n    Parse Subject Alternative Names (SANs) from a comma-separated string.\n\n    Args:\n        sans_str (str): Comma-separated SANs, e.g. \"DNS:example.com, IP:192.168.1.1\"\n\n    Returns:\n        list: List of SAN objects (DNSName or IPAddress).\n    \"\"\"\n\n    sans: list = []\n\n    for entry in sans_str.split(\",\"):\n        entry = entry.strip()\n\n        if entry.startswith(\"DNS:\"):\n            sans.append(DNSName(entry[4:]))\n        elif entry.startswith(\"IP:\"):\n            sans.append(IPAddress(ipaddress.ip_address(entry[3:])))\n\n    return sans\n\n\ndef write_pem(filename: str, data: bytes, is_key: bool = False):\n    \"\"\"\n    Write PEM data to a file.\n\n    Args:\n        filename (str): The file path to write the PEM data.\n        data (bytes): The PEM data to write.\n        is_key (bool): If True, the file is treated as a private key.\n    \"\"\"\n\n    with open(filename, \"wb\") as f:\n        f.write(data)\n\n\ndef build_subject(country: str, state: str, city: str, org: str, cn: str) -&gt; x509.Name:\n    \"\"\"\n    Build a X.500 distinguished name (DN) for a certificate subject.\n\n    Args:\n        country (str): Country name (2-letter code).\n        state (str): State or province name.\n        city (str): Locality or city name.\n        org (str): Organization name.\n        cn (str): Common name (CN) for the certificate.\n\n    Returns:\n        x509.Name: A X.500 distinguished name object.\n    \"\"\"\n\n    return x509.Name(\n        [\n            x509.NameAttribute(NameOID.COUNTRY_NAME, country),\n            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, state),\n            x509.NameAttribute(NameOID.LOCALITY_NAME, city),\n            x509.NameAttribute(NameOID.ORGANIZATION_NAME, org),\n            x509.NameAttribute(NameOID.COMMON_NAME, cn),\n        ]\n    )\n\n\ndef main():\n    \"\"\"\n    Main function to generate CA, OpenBao, and App certificates.\n    \"\"\"\n\n    args: argparse.Namespace = parse_args()\n\n    cert_dir: str = os.path.abspath(args.dir)\n    ca_dir: str = os.path.join(cert_dir, \"ca\")\n    bao_dir: str = os.path.join(cert_dir, \"bao\")\n    app_dir: str = os.path.join(cert_dir, \"app\")\n\n    os.makedirs(ca_dir, exist_ok=True)\n    os.makedirs(bao_dir, exist_ok=True)\n    os.makedirs(app_dir, exist_ok=True)\n\n    # Generate CA key and cert\n    ca_key: rsa.RSAPrivateKey = rsa.generate_private_key(\n        public_exponent=65537, key_size=4096\n    )\n    ca_subject: x509.Name = build_subject(\n        args.country, args.state, args.city, args.org, args.ca_cn\n    )\n    ca_cert: x509.Certificate = (\n        x509.CertificateBuilder()\n        .subject_name(ca_subject)\n        .issuer_name(ca_subject)\n        .public_key(ca_key.public_key())\n        .serial_number(x509.random_serial_number())\n        .not_valid_before(datetime.now(timezone.utc))\n        .not_valid_after(datetime.now(timezone.utc) + timedelta(days=3650))\n        .add_extension(x509.BasicConstraints(ca=True, path_length=None), critical=True)\n        .sign(private_key=ca_key, algorithm=hashes.SHA256())\n    )\n    write_pem(\n        os.path.join(ca_dir, \"ca.key\"),\n        ca_key.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.TraditionalOpenSSL,\n            encryption_algorithm=serialization.NoEncryption(),\n        ),\n        is_key=True,\n    )\n    write_pem(\n        os.path.join(ca_dir, \"ca.crt\"), ca_cert.public_bytes(serialization.Encoding.PEM)\n    )\n\n    # Generate OpenBao key and cert\n    bao_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\n    bao_subject: x509.Name = build_subject(\n        args.country, args.state, args.city, args.org, args.bao_cn\n    )\n    bao_sans: list[x509.Name] = parse_sans(args.bao_sans)\n    (\n        x509.CertificateSigningRequestBuilder()\n        .subject_name(bao_subject)\n        .add_extension(SubjectAlternativeName(bao_sans), critical=False)\n        .sign(bao_key, hashes.SHA256())\n    )\n    bao_cert: x509.Certificate = (\n        x509.CertificateBuilder()\n        .subject_name(bao_subject)\n        .issuer_name(ca_cert.subject)\n        .public_key(bao_key.public_key())\n        .serial_number(x509.random_serial_number())\n        .not_valid_before(datetime.now(timezone.utc))\n        .not_valid_after(datetime.now(timezone.utc) + timedelta(days=825))\n        .add_extension(SubjectAlternativeName(bao_sans), critical=False)\n        .sign(private_key=ca_key, algorithm=hashes.SHA256())\n    )\n    write_pem(\n        os.path.join(bao_dir, \"bao.key\"),\n        bao_key.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.TraditionalOpenSSL,\n            encryption_algorithm=serialization.NoEncryption(),\n        ),\n        is_key=True,\n    )\n    write_pem(\n        os.path.join(bao_dir, \"bao.crt\"),\n        bao_cert.public_bytes(serialization.Encoding.PEM),\n    )\n\n    # Generate App key and cert\n    app_key: rsa.RSAPrivateKey = rsa.generate_private_key(\n        public_exponent=65537, key_size=2048\n    )\n    app_subject: x509.Name = build_subject(\n        args.country, args.state, args.city, args.org, args.app_cn\n    )\n    app_sans: list[x509.Name] = parse_sans(args.app_sans)\n    (\n        x509.CertificateSigningRequestBuilder()\n        .subject_name(app_subject)\n        .add_extension(SubjectAlternativeName(app_sans), critical=False)\n        .sign(app_key, hashes.SHA256())\n    )\n    app_cert: x509.Certificate = (\n        x509.CertificateBuilder()\n        .subject_name(app_subject)\n        .issuer_name(ca_cert.subject)\n        .public_key(app_key.public_key())\n        .serial_number(x509.random_serial_number())\n        .not_valid_before(datetime.now(timezone.utc))\n        .not_valid_after(datetime.now(timezone.utc) + timedelta(days=825))\n        .add_extension(SubjectAlternativeName(app_sans), critical=False)\n        .sign(private_key=ca_key, algorithm=hashes.SHA256())\n    )\n    write_pem(\n        os.path.join(app_dir, \"app.key\"),\n        app_key.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.TraditionalOpenSSL,\n            encryption_algorithm=serialization.NoEncryption(),\n        ),\n        is_key=True,\n    )\n    write_pem(\n        os.path.join(app_dir, \"app.crt\"),\n        app_cert.public_bytes(serialization.Encoding.PEM),\n    )\n\n    print(f\"Certificate generation complete! Certificates are in: {cert_dir}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"scripts/setup.html","title":"Setup Script","text":""},{"location":"scripts/setup.html#overview","title":"Overview","text":"<p>This Python script automates the initial setup for Snykey. It creates the required directory structure and copies configuration files for OpenBao and Redis into the appropriate locations under <code>.container_volumes</code>. This prepares your environment for running the stack with Docker Compose.</p>"},{"location":"scripts/setup.html#features","title":"Features","text":"<ul> <li>Creates all necessary directories for logs, data, configs, and certificates.</li> <li>Copies OpenBao and Redis configuration files from the <code>configs</code> directory to their respective locations.</li> <li>Sets secure permissions on all created directories and files.</li> <li>Provides clear output for each step, making it easy to verify setup progress.</li> </ul>"},{"location":"scripts/setup.html#source","title":"Source","text":"<pre><code>import os\nimport shutil\nfrom pathlib import Path\n\n\ndef main():\n    \"\"\"\n    Main function to set up the directory structure and configuration files.\n    \"\"\"\n\n    # Get script and volume paths\n    dir_path: Path = Path(__file__).resolve().parent\n    vol: Path = dir_path.parent / \".container_volumes\"\n\n    print(\"&gt;&gt;&gt; Initializing required directories...\")\n\n    # Create necessary directories\n    dirs: list[str] = [\n        \"certs\",\n        \"app/logs\",\n        \"openbao/logs\",\n        \"openbao/data\",\n        \"openbao/config\",\n        \"openbao/certs\",\n        \"openbao/file\",\n        \"redis/config\",\n    ]\n    for d in dirs:\n        (vol / d).mkdir(parents=True, exist_ok=True)\n\n    # Copy configuration files for OpenBao\n    print(\"Transferring OpenBao config...\")\n\n    config_src: Path = dir_path.parent / \"configs\" / \"bao_config.hcl\"\n    config_dst: Path = vol / \"openbao\" / \"config\" / \"config.hcl\"\n\n    if config_src.exists():\n        shutil.copy(config_src, config_dst)\n        print(\"OpenBao config copied\")\n    else:\n        print(f\"OpenBao config not found at {config_src}\")\n\n    print(\"Transferring Redis config...\")\n\n    redis_src: Path = dir_path.parent / \"configs\" / \"redis_config.conf\"\n    redis_dst: Path = vol / \"redis\" / \"config\" / \"redis.conf\"\n\n    if redis_src.exists():\n        shutil.copy(redis_src, redis_dst)\n        print(\"Redis config copied\")\n    else:\n        print(f\"Redis config not found at {redis_src}\")\n\n    # Set permissions safely\n    for root, dirs, files in os.walk(vol):\n        for momo in dirs:\n            os.chmod(os.path.join(root, momo), 0o755)\n\n        for momo in files:\n            os.chmod(os.path.join(root, momo), 0o644)\n\n    if redis_dst.exists():\n        os.chmod(redis_dst, 0o644)\n\n    print(\"All setup steps completed.\")\n    print(\n        \"You should now run the generate_certs.py script to create the necessary certificates.\"\n    )\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"}]}