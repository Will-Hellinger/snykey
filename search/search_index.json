{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Snykey Documentation","text":"<p>Welcome to the documentation for Snykey!</p> <p></p> <p></p>"},{"location":"index.html#what-is-snykey","title":"What is Snykey?","text":"<p>Snykey is a centralized service for managing and distributing Snyk API credentials to your applications. It ensures your software always has access to valid Snyk access tokens, while securely storing and rotating refresh keys using OpenBao (Vault). This removes the persistence and secrets management burden from your application code.</p>"},{"location":"index.html#key-features","title":"Key Features","text":"<ul> <li>Centralized Snyk credential management</li> <li>Secure storage and rotation of refresh keys</li> <li>REST API for requesting and updating credentials</li> <li>OpenBao integration for robust secrets management</li> <li>Easy deployment with Docker Compose</li> </ul>"},{"location":"index.html#how-it-works","title":"How It Works","text":"<ul> <li>Applications request Snyk access tokens from the manager via the REST API.</li> <li>The manager retrieves and refreshes tokens as needed, using securely stored refresh keys.</li> <li>All secrets are stored in OpenBao, ensuring strong security and auditability.</li> </ul>"},{"location":"index.html#quick-start","title":"Quick Start","text":"<ol> <li>Clone the repository and configure your environment.</li> <li>Run the <code>setup.sh</code> script to prepare directories, configs, and certificates.</li> <li>Start the stack with Docker Compose.</li> <li>Initialize and unseal OpenBao (see Installation for details).</li> <li>Enable the KV secrets engine in OpenBao.</li> <li>Use the API to store and retrieve Snyk credentials for your applications.</li> </ol>"},{"location":"index.html#documentation-sections","title":"Documentation Sections","text":"<ul> <li>Installation: Step-by-step setup guide</li> <li>Configuration: Environment variables and service configuration</li> <li>API Reference: REST API endpoints and usage</li> </ul>"},{"location":"index.html#running-tests","title":"Running Tests","text":"<p>To run the test suite:</p> <pre><code>pip install -r tests/requirements.txt\npytest\n</code></pre>"},{"location":"index.html#openbao-setup-summary","title":"OpenBao Setup (Summary)","text":"<ol> <li> <p>Initialize OpenBao: <pre><code>docker exec -it openbao bao operator init -n 1 -t 1\n</code></pre></p> </li> <li> <p>Unseal and login: <pre><code>docker exec -it openbao bao operator unseal $OPENBAO_UNSEAL_KEY\ndocker exec -it openbao bao login $OPENBAO_TOKEN\n</code></pre></p> </li> <li> <p>Enable secrets engine: <pre><code>docker exec -it openbao bao secrets enable -version=2 kv\n</code></pre></p> </li> </ol>"},{"location":"endpoints/v1.html","title":"v1","text":""},{"location":"endpoints/v1.html#v1-endpoints","title":"V1 Endpoints","text":""},{"location":"endpoints/v1.html#overview","title":"Overview","text":"<p>This API provides endpoints for securely storing, retrieving, and deleting Snyk credentials using OpenBao (Vault) and Redis as backends. All endpoints are versioned under <code>/credentials</code> and <code>/cache</code>.</p>"},{"location":"endpoints/v1.html#authentication","title":"Authentication","text":"<p>This API does not implement authentication by default. If you deploy in production, you should secure the API (e.g., with a reverse proxy, network policy, or FastAPI dependencies).</p>"},{"location":"endpoints/v1.html#error-handling","title":"Error Handling","text":"<ul> <li>All endpoints return JSON responses.</li> <li>On error, the response will include an <code>error</code> field and an appropriate HTTP status code (e.g., 400, 404, 500, 503).</li> </ul> <p>Example error response: <pre><code>{\n  \"error\": \"Vault is sealed, cannot store credentials.\"\n}\n</code></pre></p>"},{"location":"endpoints/v1.html#endpoint-overview","title":"Endpoint Overview","text":""},{"location":"endpoints/v1.html#api.v1.endpoints.delete_cache_key","title":"<code>delete_cache_key</code>","text":"<p>Deletes the Snyk auth token for the specified org/client from Redis.</p> <p>Parameters:</p> Name Type Description Default <code>org_id</code> <code>str</code> <p>The organization ID.</p> required <code>client_id</code> <code>str</code> <p>The client ID.</p> required <p>Returns:</p> Name Type Description <code>JSONResponse</code> <code>JSONResponse</code> <p>A confirmation message indicating the auth token was deleted.</p> Source code in <code>snykey/api/v1/endpoints.py</code> <pre><code>@router.delete(\"/cache\")\ndef delete_cache_key(org_id: str, client_id: str) -&gt; JSONResponse:\n    \"\"\"\n    Deletes the Snyk auth token for the specified org/client from Redis.\n\n    Args:\n        org_id (str): The organization ID.\n        client_id (str): The client ID.\n\n    Returns:\n        JSONResponse: A confirmation message indicating the auth token was deleted.\n    \"\"\"\n\n    response: dict = redis.delete_auth_token(org_id, client_id)\n\n    return JSONResponse(content=response)\n</code></pre>"},{"location":"endpoints/v1.html#api.v1.endpoints.delete_credentials","title":"<code>delete_credentials</code>","text":"<p>Delete Snyk credentials for a given org_id and client_id.</p> <p>Parameters:</p> Name Type Description Default <code>org_id</code> <code>str</code> <p>The organization ID.</p> required <code>client_id</code> <code>str</code> <p>The client ID.</p> required <p>Returns:</p> Name Type Description <code>JSONResponse</code> <code>JSONResponse</code> <p>A response indicating success or failure of the deletion.</p> Source code in <code>snykey/api/v1/endpoints.py</code> <pre><code>@router.delete(\"/credentials\")\ndef delete_credentials(org_id: str, client_id: str) -&gt; JSONResponse:\n    \"\"\"\n    Delete Snyk credentials for a given org_id and client_id.\n\n    Args:\n        org_id (str): The organization ID.\n        client_id (str): The client ID.\n\n    Returns:\n        JSONResponse: A response indicating success or failure of the deletion.\n    \"\"\"\n\n    if not org_id or not client_id:\n        return JSONResponse(\n            status_code=400, content={\"error\": \"org_id and client_id are required\"}\n        )\n\n    # Delete auth token from Redis\n    logger.info(\n        \"Deleting auth token from Redis for org_id: %s, client_id: %s\",\n        org_id,\n        client_id,\n    )\n\n    redis.delete_auth_token(org_id, client_id)\n\n    openbao.delete_refresh_key(org_id, client_id)\n\n    return JSONResponse(content={\"message\": \"Credentials deleted.\"})\n</code></pre>"},{"location":"endpoints/v1.html#api.v1.endpoints.get_credentials","title":"<code>get_credentials</code>","text":"<p>Gather Snyk credentials using the provided org_id and client_id.</p> <p>Parameters:</p> Name Type Description Default <code>org_id</code> <code>str</code> <p>The organization ID.</p> required <code>client_id</code> <code>str</code> <p>The client ID.</p> required <p>Returns:</p> Name Type Description <code>JSONResponse</code> <code>JSONResponse</code> <p>A response containing the gathered credentials or an error message.</p> Source code in <code>snykey/api/v1/endpoints.py</code> <pre><code>@router.get(\"/credentials\")\ndef get_credentials(org_id: str, client_id: str, client_secret: str) -&gt; JSONResponse:\n    \"\"\"\n    Gather Snyk credentials using the provided org_id and client_id.\n\n    Args:\n        org_id (str): The organization ID.\n        client_id (str): The client ID.\n\n    Returns:\n        JSONResponse: A response containing the gathered credentials or an error message.\n    \"\"\"\n\n    # Check if auth token exists in Redis\n    logger.info(\n        \"Checking Redis for auth token for org_id: %s, client_id: %s\",\n        org_id,\n        client_id,\n    )\n\n    auth_token: bytes | None = None\n\n    try:\n        auth_token = redis.get_auth_token(org_id, client_id)\n    except Exception as e:\n        logger.error(\"Failed to retrieve auth token from Redis: %s\", e)\n\n    if auth_token:\n        logger.info(\"Found auth token in Redis\")\n        return JSONResponse(content={\"access_token\": str(auth_token.decode())})\n\n    # Get refresh key from OpenBao\n    logger.info(\n        \"Gathering Snyk credentials for org_id: %s, client_id: %s\",\n        org_id,\n        client_id,\n    )\n\n    refresh_key: str | None = openbao.get_refresh_key(org_id, client_id)\n\n    if not refresh_key:\n        return JSONResponse(\n            status_code=404, content={\"error\": \"No refresh key found for org/client\"}\n        )\n\n    # Refresh Snyk token\n    logger.info(\n        \"Refreshing Snyk token for org_id: %s, client_id: %s\", org_id, client_id\n    )\n    try:\n        result: dict = snyk.refresh_snyk_token(client_id, client_secret, refresh_key)\n\n        logger.info(\n            \"Successfully refreshed Snyk token for org_id: %s, client_id: %s\",\n            org_id,\n            client_id,\n        )\n        openbao.update_refresh_key(org_id, client_id, result[\"refresh_token\"])\n    except Exception as e:\n        logger.error(\"Failed to refresh Snyk token: %s\", e)\n        return JSONResponse(status_code=500, content={\"error\": str(e)})\n\n    try:\n        redis.store_auth_token(\n            org_id,\n            client_id,\n            str(result[\"access_token\"]),\n            expiration=settings.REDIS_CACHE_TIME * 60,\n        )\n    except Exception as e:\n        logger.error(\"Failed to store auth token in Redis: %s\", e)\n        return JSONResponse(status_code=500, content={\"error\": str(e)})\n\n    return JSONResponse(content={\"access_token\": str(result[\"access_token\"])})\n</code></pre>"},{"location":"endpoints/v1.html#api.v1.endpoints.store_credentials","title":"<code>store_credentials</code>","text":"<p>Store Snyk credentials in OpenBao.</p> <p>Parameters:</p> Name Type Description Default <code>org_id</code> <code>str</code> <p>The organization ID.</p> required <code>client_id</code> <code>str</code> <p>The client ID.</p> required <code>client_secret</code> <code>str</code> <p>The client secret.</p> required <code>refresh_key</code> <code>str</code> <p>The refresh key.</p> required <p>Returns:</p> Name Type Description <code>JSONResponse</code> <code>JSONResponse</code> <p>A response indicating success or failure.</p> Source code in <code>snykey/api/v1/endpoints.py</code> <pre><code>@router.put(\"/credentials\")\ndef store_credentials(\n    org_id: str, client_id: str, client_secret: str, refresh_key: str\n) -&gt; JSONResponse:\n    \"\"\"\n    Store Snyk credentials in OpenBao.\n\n    Args:\n        org_id (str): The organization ID.\n        client_id (str): The client ID.\n        client_secret (str): The client secret.\n        refresh_key (str): The refresh key.\n\n    Returns:\n        JSONResponse: A response indicating success or failure.\n    \"\"\"\n\n    if openbao.check_vault_sealed():\n        return JSONResponse(\n            status_code=503,\n            content={\"error\": \"Vault is sealed, cannot store credentials.\"},\n        )\n\n    logger.info(\"Refreshing key to ensure no other process can use it.\")\n    try:\n        result: dict = snyk.refresh_snyk_token(client_id, client_secret, refresh_key)\n\n        logger.info(\n            \"Successfully refreshed Snyk token for org_id: %s, client_id: %s\",\n            org_id,\n            client_id,\n        )\n\n        openbao.store_refresh_key(org_id, client_id, result[\"refresh_token\"])\n    except Exception as e:\n        logger.error(\"Failed to refresh Snyk token: %s\", e)\n        return JSONResponse(status_code=500, content={\"error\": str(e)})\n\n    return JSONResponse(content={\"message\": \"Credentials stored.\"})\n</code></pre>"},{"location":"getting-started/configuration.html","title":"Configuration","text":"<p>Snykey is highly configurable to fit a variety of deployment environments. Below are the main configuration options you can adjust to suit your needs.</p>"},{"location":"getting-started/configuration.html#environment-variables","title":"Environment Variables","text":"<p>Most configuration is handled via environment variables, typically set in your <code>.env</code> file or passed directly to Docker Compose. See <code>.env_example</code> for a template.</p> Variable Description Default/Example <code>OPENBAO_ADDR</code> URL for the OpenBao server <code>https://openbao:8200</code> <code>OPENBAO_TOKEN</code> Root token for OpenBao (set after init) <code>OPENBAO_UNSEAL_KEY</code> Unseal key for OpenBao (set after init) <code>REDIS_HOST</code> Hostname for Redis <code>redis</code> <code>REDIS_PORT</code> Port for Redis <code>6379</code> <code>REDIS_PASSWORD</code> Password for Redis <code>example_password</code> <code>REDIS_CACHE_TIME</code> Cache time (in minutes) for Redis tokens <code>50</code> <p>You can modify these in your <code>.env</code> file or override them in your deployment environment.</p>"},{"location":"getting-started/configuration.html#redis-configuration","title":"Redis Configuration","text":"<p>Redis is configured via <code>configs/redis_config.conf</code>. You can adjust:</p> <ul> <li>Port: Change the <code>port</code> directive.</li> <li>Password: Set <code>requirepass</code> to your desired password.</li> <li>Persistence: Adjust <code>appendonly</code> and <code>appendfsync</code> for durability/performance.</li> <li>Logging: Change <code>loglevel</code> as needed.</li> </ul> <p>Example: <pre><code>port 6379\nloglevel debug\nbind 0.0.0.0\n\nrequirepass example_password\n\nappendonly yes\nappendfsync everysec\n</code></pre></p>"},{"location":"getting-started/installation.html","title":"Installation","text":"<p>Follow these steps to install and set up Snykey.</p>"},{"location":"getting-started/installation.html#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/Will-Hellinger/snykey.git\ncd snykey\n</code></pre>"},{"location":"getting-started/installation.html#2-prepare-configuration","title":"2. Prepare Configuration","text":"<p>Copy .env_example to .env and fill in your secrets and environment-specific values. Adjust any configuration in configs/ if needed.</p>"},{"location":"getting-started/installation.html#3-run-the-setup-script","title":"3. Run the Setup Script","text":"<p>The setup script will:</p> <ul> <li>Create required directories and volume mounts</li> <li>Copy configuration files for OpenBao and Redis</li> <li>Generate self-signed certificates for local development</li> </ul> <p>Run: <code>sh /scripts/setup.sh</code></p>"},{"location":"getting-started/installation.html#4-start-the-stack","title":"4. Start the Stack","text":"<p>Start all services with Docker Compose:</p> <pre><code>docker compose up -d --build\n</code></pre>"},{"location":"getting-started/installation.html#5-initialize-and-unseal-openbao","title":"5. Initialize and Unseal OpenBao","text":""},{"location":"getting-started/installation.html#a-initialize-openbao-first-time-only","title":"a. Initialize OpenBao (first time only):","text":"<pre><code>docker exec -it openbao bao operator init -n 1 -t 1\n</code></pre> <ul> <li>Save the Unseal Key and Root Token from the output.</li> <li>Add them to your .env file as OPENBAO_UNSEAL_KEY and OPENBAO_TOKEN.</li> </ul>"},{"location":"getting-started/installation.html#b-restart-the-stack","title":"b. Restart the Stack","text":"<pre><code>docker compose down\n</code></pre> <pre><code>docker compose up -d\n</code></pre>"},{"location":"getting-started/installation.html#c-unseal-openbao","title":"c. Unseal OpenBao:","text":"<pre><code>docker exec -it openbao bao operator unseal $OPENBAO_UNSEAL_KEY\n</code></pre>"},{"location":"getting-started/installation.html#d-login-to-openbao","title":"d. Login to OpenBao:","text":"<pre><code>docker exec -it openbao bao login $OPENBAO_TOKEN\n</code></pre>"},{"location":"getting-started/installation.html#6-enable-the-key-value-secrets-engine","title":"6. Enable the Key-Value Secrets Engine","text":"<p>Enable the KV secrets engine (version 2):</p> <pre><code>docker exec -it openbao bao secrets enable -version=2 kv\n</code></pre>"},{"location":"getting-started/installation.html#7-optional-verify-everything-is-running","title":"7. (Optional) Verify Everything is Running","text":"<ul> <li>Visit <code>https://localhost:8000/docs</code> for the API docs.</li> <li>Check logs in .container_volumes/app/logs/ if needed.</li> </ul>"},{"location":"getting-started/installation.html#8-next-steps","title":"8. Next Steps","text":"<ul> <li>Use the API to store and retrieve Snyk credentials for your applications.</li> <li>For production, replace the generated certificates with your own trusted certificates.</li> </ul>"},{"location":"scripts/generate-certificates.html","title":"Certificate Generation Script","text":""},{"location":"scripts/generate-certificates.html#overview","title":"Overview","text":"<p>This Bash script automates the creation of a local Certificate Authority (CA) and generates signed TLS certificates for two entities: \"OpenBao\" and \"App\". It uses OpenSSL to generate private keys, certificate signing requests (CSRs), and signed certificates, including Subject Alternative Names (SANs) for both server and client authentication. The script is designed to be used in development or testing environments where self-signed certificates are sufficient.</p>"},{"location":"scripts/generate-certificates.html#features","title":"Features","text":"<ul> <li>Creates a local CA with its own private key and certificate.</li> <li>Generates private keys and CSRs for \"OpenBao\" and \"App\".</li> <li>Signs the CSRs with the local CA, producing valid certificates.</li> <li>Supports custom configuration for certificate subject fields and SANs.</li> <li>Cleans up intermediate files and sets secure permissions on keys and certificates.</li> </ul>"},{"location":"scripts/generate-certificates.html#source","title":"Source","text":"<pre><code>import os\nimport argparse\nfrom cryptography import x509\nfrom cryptography.x509.oid import NameOID\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.x509 import DNSName, IPAddress, SubjectAlternativeName\nfrom datetime import datetime, timedelta, timezone\nimport ipaddress\n\nDEFAULT_CERT_DIR: str = \".container_volumes/certs\"\nDEFAULT_COUNTRY: str = \"US\"\nDEFAULT_STATE: str = \"State\"\nDEFAULT_CITY: str = \"City\"\nDEFAULT_ORG: str = \"OrgName\"\nDEFAULT_CA_CN: str = \"InternalCA\"\nDEFAULT_BAO_CN: str = \"openbao\"\nDEFAULT_APP_CN: str = \"app\"\nDEFAULT_BAO_SANS: list[str] = [\n    \"DNS:openbao\",\n    \"DNS:localhost\",\n    \"DNS:host.docker.internal\",\n    \"IP:127.0.0.1\",\n]\nDEFAULT_APP_SANS: list[str] = [\n    \"DNS:app\",\n    \"DNS:localhost\",\n    \"DNS:host.docker.internal\",\n    \"IP:127.0.0.1\",\n]\n\n\ndef parse_args() -&gt; argparse.Namespace:\n    parser: argparse.ArgumentParser = argparse.ArgumentParser(\n        description=\"Generate CA, OpenBao, and App certificates.\"\n    )\n\n    parser.add_argument(\"-d\", \"--dir\", default=DEFAULT_CERT_DIR, help=\"Output cert dir\")\n    parser.add_argument(\"-c\", \"--country\", default=DEFAULT_COUNTRY)\n    parser.add_argument(\"-s\", \"--state\", default=DEFAULT_STATE)\n    parser.add_argument(\"-l\", \"--city\", default=DEFAULT_CITY)\n    parser.add_argument(\"-o\", \"--org\", default=DEFAULT_ORG)\n    parser.add_argument(\"--ca-cn\", default=DEFAULT_CA_CN)\n    parser.add_argument(\"--bao-cn\", default=DEFAULT_BAO_CN)\n    parser.add_argument(\"--app-cn\", default=DEFAULT_APP_CN)\n    parser.add_argument(\"--bao-sans\", default=\",\".join(DEFAULT_BAO_SANS))\n    parser.add_argument(\"--app-sans\", default=\",\".join(DEFAULT_APP_SANS))\n\n    return parser.parse_args()\n\n\ndef parse_sans(sans_str: str) -&gt; list:\n    \"\"\"\n    Parse Subject Alternative Names (SANs) from a comma-separated string.\n\n    Args:\n        sans_str (str): Comma-separated SANs, e.g. \"DNS:example.com, IP:192.168.1.1\"\n\n    Returns:\n        list: List of SAN objects (DNSName or IPAddress).\n    \"\"\"\n\n    sans: list = []\n\n    for entry in sans_str.split(\",\"):\n        entry = entry.strip()\n\n        if entry.startswith(\"DNS:\"):\n            sans.append(DNSName(entry[4:]))\n        elif entry.startswith(\"IP:\"):\n            sans.append(IPAddress(ipaddress.ip_address(entry[3:])))\n\n    return sans\n\n\ndef write_pem(filename: str, data: bytes, is_key: bool = False):\n    \"\"\"\n    Write PEM data to a file.\n\n    Args:\n        filename (str): The file path to write the PEM data.\n        data (bytes): The PEM data to write.\n        is_key (bool): If True, the file is treated as a private key.\n    \"\"\"\n\n    with open(filename, \"wb\") as f:\n        f.write(data)\n\n\ndef build_subject(country: str, state: str, city: str, org: str, cn: str) -&gt; x509.Name:\n    \"\"\"\n    Build a X.500 distinguished name (DN) for a certificate subject.\n\n    Args:\n        country (str): Country name (2-letter code).\n        state (str): State or province name.\n        city (str): Locality or city name.\n        org (str): Organization name.\n        cn (str): Common name (CN) for the certificate.\n\n    Returns:\n        x509.Name: A X.500 distinguished name object.\n    \"\"\"\n\n    return x509.Name(\n        [\n            x509.NameAttribute(NameOID.COUNTRY_NAME, country),\n            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, state),\n            x509.NameAttribute(NameOID.LOCALITY_NAME, city),\n            x509.NameAttribute(NameOID.ORGANIZATION_NAME, org),\n            x509.NameAttribute(NameOID.COMMON_NAME, cn),\n        ]\n    )\n\n\ndef main():\n    \"\"\"\n    Main function to generate CA, OpenBao, and App certificates.\n    \"\"\"\n\n    args: argparse.Namespace = parse_args()\n\n    cert_dir: str = os.path.abspath(args.dir)\n    ca_dir: str = os.path.join(cert_dir, \"ca\")\n    bao_dir: str = os.path.join(cert_dir, \"bao\")\n    app_dir: str = os.path.join(cert_dir, \"app\")\n\n    os.makedirs(ca_dir, exist_ok=True)\n    os.makedirs(bao_dir, exist_ok=True)\n    os.makedirs(app_dir, exist_ok=True)\n\n    # Generate CA key and cert\n    ca_key: rsa.RSAPrivateKey = rsa.generate_private_key(\n        public_exponent=65537, key_size=4096\n    )\n    ca_subject: x509.Name = build_subject(\n        args.country, args.state, args.city, args.org, args.ca_cn\n    )\n    ca_cert: x509.Certificate = (\n        x509.CertificateBuilder()\n        .subject_name(ca_subject)\n        .issuer_name(ca_subject)\n        .public_key(ca_key.public_key())\n        .serial_number(x509.random_serial_number())\n        .not_valid_before(datetime.now(timezone.utc))\n        .not_valid_after(datetime.now(timezone.utc) + timedelta(days=3650))\n        .add_extension(x509.BasicConstraints(ca=True, path_length=None), critical=True)\n        .sign(private_key=ca_key, algorithm=hashes.SHA256())\n    )\n    write_pem(\n        os.path.join(ca_dir, \"ca.key\"),\n        ca_key.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.TraditionalOpenSSL,\n            encryption_algorithm=serialization.NoEncryption(),\n        ),\n        is_key=True,\n    )\n    write_pem(\n        os.path.join(ca_dir, \"ca.crt\"), ca_cert.public_bytes(serialization.Encoding.PEM)\n    )\n\n    # Generate OpenBao key and cert\n    bao_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\n    bao_subject: x509.Name = build_subject(\n        args.country, args.state, args.city, args.org, args.bao_cn\n    )\n    bao_sans: list[x509.Name] = parse_sans(args.bao_sans)\n    bao_csr: x509.CertificateSigningRequest = (\n        x509.CertificateSigningRequestBuilder()\n        .subject_name(bao_subject)\n        .add_extension(SubjectAlternativeName(bao_sans), critical=False)\n        .sign(bao_key, hashes.SHA256())\n    )\n    bao_cert: x509.Certificate = (\n        x509.CertificateBuilder()\n        .subject_name(bao_subject)\n        .issuer_name(ca_cert.subject)\n        .public_key(bao_key.public_key())\n        .serial_number(x509.random_serial_number())\n        .not_valid_before(datetime.now(timezone.utc))\n        .not_valid_after(datetime.now(timezone.utc) + timedelta(days=825))\n        .add_extension(SubjectAlternativeName(bao_sans), critical=False)\n        .sign(private_key=ca_key, algorithm=hashes.SHA256())\n    )\n    write_pem(\n        os.path.join(bao_dir, \"bao.key\"),\n        bao_key.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.TraditionalOpenSSL,\n            encryption_algorithm=serialization.NoEncryption(),\n        ),\n        is_key=True,\n    )\n    write_pem(\n        os.path.join(bao_dir, \"bao.crt\"),\n        bao_cert.public_bytes(serialization.Encoding.PEM),\n    )\n\n    # Generate App key and cert\n    app_key: rsa.RSAPrivateKey = rsa.generate_private_key(\n        public_exponent=65537, key_size=2048\n    )\n    app_subject: x509.Name = build_subject(\n        args.country, args.state, args.city, args.org, args.app_cn\n    )\n    app_sans: list[x509.Name] = parse_sans(args.app_sans)\n    app_csr: x509.CertificateSigningRequest = (\n        x509.CertificateSigningRequestBuilder()\n        .subject_name(app_subject)\n        .add_extension(SubjectAlternativeName(app_sans), critical=False)\n        .sign(app_key, hashes.SHA256())\n    )\n    app_cert: x509.Certificate = (\n        x509.CertificateBuilder()\n        .subject_name(app_subject)\n        .issuer_name(ca_cert.subject)\n        .public_key(app_key.public_key())\n        .serial_number(x509.random_serial_number())\n        .not_valid_before(datetime.now(timezone.utc))\n        .not_valid_after(datetime.now(timezone.utc) + timedelta(days=825))\n        .add_extension(SubjectAlternativeName(app_sans), critical=False)\n        .sign(private_key=ca_key, algorithm=hashes.SHA256())\n    )\n    write_pem(\n        os.path.join(app_dir, \"app.key\"),\n        app_key.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.TraditionalOpenSSL,\n            encryption_algorithm=serialization.NoEncryption(),\n        ),\n        is_key=True,\n    )\n    write_pem(\n        os.path.join(app_dir, \"app.crt\"),\n        app_cert.public_bytes(serialization.Encoding.PEM),\n    )\n\n    print(f\"Certificate generation complete! Certificates are in: {cert_dir}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"scripts/setup.html","title":"Setup Script","text":""},{"location":"scripts/setup.html#overview","title":"Overview","text":"<p>This Python script automates the initial setup for Snykey. It creates the required directory structure and copies configuration files for OpenBao and Redis into the appropriate locations under <code>.container_volumes</code>. This prepares your environment for running the stack with Docker Compose.</p>"},{"location":"scripts/setup.html#features","title":"Features","text":"<ul> <li>Creates all necessary directories for logs, data, configs, and certificates.</li> <li>Copies OpenBao and Redis configuration files from the <code>configs</code> directory to their respective locations.</li> <li>Sets secure permissions on all created directories and files.</li> <li>Provides clear output for each step, making it easy to verify setup progress.</li> </ul>"},{"location":"scripts/setup.html#source","title":"Source","text":"<pre><code>import os\nimport shutil\nfrom pathlib import Path\n\ndef main():\n    \"\"\"\n    Main function to set up the directory structure and configuration files.\n    \"\"\"\n\n    # Get script and volume paths\n    dir_path: Path = Path(__file__).resolve().parent\n    vol: Path = dir_path.parent / \".container_volumes\"\n\n    print(\"&gt;&gt;&gt; Initializing required directories...\")\n\n    # Create necessary directories\n    dirs: list[str] = [\n        \"certs\",\n        \"app/logs\",\n        \"openbao/logs\",\n        \"openbao/data\",\n        \"openbao/config\",\n        \"openbao/certs\",\n        \"openbao/file\",\n        \"redis/config\",\n    ]\n    for d in dirs:\n        (vol / d).mkdir(parents=True, exist_ok=True)\n\n    # Copy configuration files for OpenBao\n    print(\"Transferring OpenBao config...\")\n\n    config_src: Path = dir_path.parent / \"configs\" / \"bao_config.hcl\"\n    config_dst: Path = vol / \"openbao\" / \"config\" / \"config.hcl\"\n\n    if config_src.exists():\n        shutil.copy(config_src, config_dst)\n        print(\"OpenBao config copied\")\n    else:\n        print(f\"OpenBao config not found at {config_src}\")\n\n    print(\"Transferring Redis config...\")\n\n    redis_src: Path = dir_path.parent / \"configs\" / \"redis_config.conf\"\n    redis_dst: Path = vol / \"redis\" / \"config\" / \"redis.conf\"\n\n    if redis_src.exists():\n        shutil.copy(redis_src, redis_dst)\n        print(\"Redis config copied\")\n    else:\n        print(f\"Redis config not found at {redis_src}\")\n\n    # Set permissions safely\n    for root, dirs, files in os.walk(vol):\n        for momo in dirs:\n            os.chmod(os.path.join(root, momo), 0o755)\n\n        for momo in files:\n            os.chmod(os.path.join(root, momo), 0o644)\n\n    if redis_dst.exists():\n        os.chmod(redis_dst, 0o644)\n\n    print(\"All setup steps completed.\")\n    print(\"You should now run the generate_certs.py script to create the necessary certificates.\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"}]}